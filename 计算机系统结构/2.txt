8. 请简述Cache的3C失效。
	三种类型的不命中：Compulsory/Capacity/Conflict
9. 请针对3C失效的每种失效给出一种降低失效率的方法，并分别分析该种方法的缺点。
10.请简述伪相联的基本思想。
降低不命中率
	三种类型的不命中：Compulsory/Capacity/Conflict
		○ 相联度越高，冲突不命中就越少
		○ 强制性不命中和容量不命中不受相联度的影响
		○ 强制性不命中不受Cache容量的影响
		○ 容量不命中却随着容量的增加而减少
	• 针对强制不命中
		○ 法1：增加块的大小。
			§ 但是对于固定容量的Cache，会减少块数目，增加冲突不命中。还会增加不命中的开销。
	• 针对容量不命中
		○ 法2：增加Cache容量。
			§ 增加成本。增加命中时间。一般用在低层次的cache中。
	• 针对冲突不命中
		○ 法3：提高相联度。
			§ 相联度超过8的意义不大。
			§ 还会增加命中时间。
	• 法4：伪相联
		○ 结合了命中时间小和不命中率低两个优点。
			§ 会有快速命中和慢速命中。需要在一次命中后交换位置。
	• 法5：硬件预取
		○ 指令/数据预取。
	• 法6：编译器控制的预取
		○ 寄存器预取，Cache预取
		○ 在预取的同时，处理器应当能够继续执行
		○ 循环是预取优化的主要对象，不命中开销大时，循环体应该展开多次
		○ 
	• 法7：编译器优化
		○ 无需对硬件做任何改动
		○ 程序代码和数据重组：指令重排、基本块对齐
		○ 数组合并，内外循环交换，循环融合，分块
	• 法8：牺牲cache
		○ 在Cache和它从下一级存储器调数据的通路之间设置一个全相联的小Cache
减少不命中开销
	• 法1：两/多级Cache
	• 法2：让读不命中优先于写
		§ 读不命中时，所读单元的最新值可能还在写缓冲器中。
		§ 有两种解决方法：
			§ 推迟读，写完后再读。
			§ 读不命中优先，检查缓冲器中的内容，如果没有地址相同的，就直接访问存储器，不等待写
	• 法3：写缓冲合并
		○ 提高写缓冲器的效率
		○ 对于写直达Cache，如果写缓冲器空，直接写入；否则比较缓冲器中已有地址，是否有匹配项。如有匹配的项，把数据合并。这就叫写缓冲合并
		○ 如果缓冲器满，且无法合并的，就必须等待
	• 法4：请求字处理技术
		○ 只有一个字是立即需要的，请求字
		○ 尽早重启动：从块的起始位置开始读，读到请求字就发送
		○ 请求字优先：从请求字的位置开始读
		○ 当cache块较小，或下一条指令访问请求字的前面部分时，效果不好
	• 法5：非阻塞cache
		○ Cache不命中时仍然允许CPU进行其他的命中访问
			§ 但是得优化“多重不命中下的命中”“不命中下不命中”
减少命中时间
	• 法1：使用小容量、结构简单的Cache
	• 发2：使用虚拟Cache
		○ 普通的物理Cache
			§ 
			§ 需要首先转换成物理地址
		○ 虚拟Cache
			§ 
			§ 每当进程切换时，需要清空cache
		○ 虚拟索引+物理标识
			§ 用虚拟地址中的页内位移作为索引
			§ Cache容量≤页大小×相联度
	• 法3：Cache访问流水化
		○ 实际上并没有减少命中时间，而是提高了带宽
	• 法4：踪迹Cache
		○ 存储CPU执行过的动态指令序列，包含了由分支预测展开了的指令
		○ 
		
